---
description: Rule describing the structure and behavior of background job workers in 'back/src/jobs', including advisory locking, job lifecycle, architecture, and FastAPI application integration.
alwaysApply: false
---
# Background Jobs

## Overview

Background jobs run embedded in the FastAPI application and are started during app lifespan. They use PostgreSQL advisory locks (`pg_advisory_xact_lock`) to ensure only one instance runs at a time, even across multiple application replicas.

## Architecture

Jobs are split into two categories:

```
src/jobs/                         # General jobs (work for all games)
  base.py                         # BaseJob abstract class
  room_cleanup.py                 # RoomCleanupJob - closes inactive rooms
  __init__.py

src/games/guess_number/jobs/      # Game-specific jobs
  timer.py                        # GuessNumberTimerJob - round timing
  __init__.py
```

Jobs are started in `src/main.py` within the lifespan context manager.

## How Jobs Work

1. Job runs in an infinite loop with configurable sleep interval
2. Each iteration acquires a PostgreSQL advisory lock (non-blocking)
3. If lock is acquired, executes the job logic within a transaction
4. Lock is automatically released when transaction ends
5. Sleeps for the configured interval before next iteration

```python
# Simplified flow
while True:
    async with session:
        lock_acquired = await session.execute(
            "SELECT pg_try_advisory_xact_lock(:lock_id)"
        )
        if lock_acquired:
            await self.execute(session)
            await session.commit()
    await asyncio.sleep(self.interval_seconds)
```

## Existing Jobs

### General Jobs (src/jobs/)

#### RoomCleanupJob (`lock_id: 1002`)
- **Purpose**: Closes rooms that have been inactive for too long
- **Interval**: 1 hour (configurable via `room_cleanup_job_interval`)
- **Actions**: 
  - Finds rooms in WAITING or PLAYING status with old `updated_at`
  - Sets status to ABANDONED
  - Broadcasts ROOM_CLOSED event via WebSocket

### Game-Specific Jobs

#### GuessNumberTimerJob (`lock_id: 1001`)
- **Location**: `src/games/guess_number/jobs/timer.py`
- **Purpose**: Manages round timing for Guess the Number game
- **Interval**: 1 second (configurable via `game_timer_job_interval`)
- **Actions**: 
  - Finishes rounds when time expires or all players voted
  - Calculates and awards points
  - Broadcasts results via WebSocket
  - Starts next round after delay or ends game
- **Game settings used** (from `games.yaml`):
  - `round_duration_seconds` - how long each round lasts
  - `between_rounds_delay_seconds` - pause between rounds
  - `total_rounds` - number of rounds before game ends

## Adding a New General Job

1. **Create job file** in `src/jobs/`:

```python
# src/jobs/my_new_job.py
from sqlalchemy.ext.asyncio import AsyncSession
from src.jobs.base import BaseJob

class MyNewJob(BaseJob):
    # Unique lock ID - pick a number not used by other jobs
    lock_id = 1003
    
    # How often to run (seconds)
    interval_seconds = 5.0
    
    # Name for logging
    job_name = "MyNewJob"

    async def execute(self, session: AsyncSession):
        """
        Job logic here. Session is already in a transaction
        with advisory lock held.
        """
        # Query database
        result = await session.execute(...)
        
        # Do work
        ...
        
        # Changes are committed automatically after execute() returns
```

2. **Export from `__init__.py`**:

```python
# src/jobs/__init__.py
from src.jobs.base import BaseJob
from src.jobs.room_cleanup import RoomCleanupJob
from src.jobs.my_new_job import MyNewJob

__all__ = ["BaseJob", "RoomCleanupJob", "MyNewJob"]
```

3. **Register in `main.py`**:

```python
# src/main.py
from src.jobs.my_new_job import MyNewJob

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Start background jobs
    my_new_job = MyNewJob()
    
    tasks = [
        asyncio.create_task(my_new_job.run()),
        # ... other tasks
    ]
    
    yield
    
    # Cleanup
    for task in tasks:
        task.cancel()
```

## Adding a Game-Specific Job

Game-specific jobs should live in the game's directory. See the Games Architecture rule (`games.mdc`) for full instructions.

```
src/games/my_game/
  jobs/
    __init__.py
    timer.py        # MyGameTimerJob
```

**Key difference**: Game-specific jobs should filter by `game_type` to only process rooms for their game:

```python
result = await session.execute(
    select(Room).where(
        Room.status == RoomStatus.PLAYING,
        Room.game_type == "my_game",  # Filter by game type!
    )
)
```

## Configuration

Job settings are in `src/config.py`:

```python
class Settings(BaseSettings):
    # Job intervals
    game_timer_job_interval: float = 1.0
    room_cleanup_job_interval: float = 3600.0  # 1 hour
    room_inactivity_threshold_hours: int = 24
```

Game-specific settings (like `round_duration_seconds`) should go in `games.yaml` under the game's `settings` section.

## Lock ID Registry

Keep track of lock IDs to avoid conflicts:

| Lock ID | Job Name              | Location                           | Description                |
|---------|-----------------------|------------------------------------|----------------------------|
| 1001    | GuessNumberTimerJob   | src/games/guess_number/jobs/timer.py | Round timer for guess_number |
| 1002    | RoomCleanupJob        | src/jobs/room_cleanup.py           | Closes inactive rooms      |
| 1003    | (available)           | -                                  | -                          |

## Testing Jobs

Jobs can be tested by calling `execute()` directly with a test session:

```python
async def test_my_job(session: AsyncSession):
    job = MyNewJob()
    await job.execute(session)
    # Assert expected changes
```

For game-specific jobs, make sure to create rooms with the correct `game_type`:

```python
async def test_guess_number_timer(session: AsyncSession):
    # Create room with game_type="guess_number"
    room = Room(game_type="guess_number", ...)
    
    job = GuessNumberTimerJob()
    await job.execute(session)
```
